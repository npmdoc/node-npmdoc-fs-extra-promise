<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

    >fs-extra-promise (v1.0.1)</a>
</h1>
<h4>Node file system library and fs-extra module promisified with bluebird</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise">module fs-extra-promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.FileReadStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>FileReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.FileWriteStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>FileWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ReadStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>Stats
            <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.WriteStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>WriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise._toUnixTimestamp">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>_toUnixTimestamp
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise._toUnixTimestampAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>_toUnixTimestampAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.access">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>access
            <span class="apidocSignatureSpan">(path, mode, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.accessAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>accessAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.accessSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>accessSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.appendFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>appendFile
            <span class="apidocSignatureSpan">(path, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.appendFileAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>appendFileAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.appendFileSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>appendFileSync
            <span class="apidocSignatureSpan">(path, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.chmod">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>chmod
            <span class="apidocSignatureSpan">(target, mode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.chmodAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>chmodAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.chmodSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>chmodSync
            <span class="apidocSignatureSpan">(target, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.chown">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>chown
            <span class="apidocSignatureSpan">(target, uid, gid, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.chownAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>chownAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.chownSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>chownSync
            <span class="apidocSignatureSpan">(target, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.close">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>close
            <span class="apidocSignatureSpan">(fd, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.closeAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>closeAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.closeSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>closeSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.copy">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>copy
            <span class="apidocSignatureSpan">(src, dest, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.copyAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>copyAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.copySync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>copySync
            <span class="apidocSignatureSpan">(src, dest, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createFile
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createFileAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createFileAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createFileSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createFileSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createLink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createLink
            <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createLinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createLinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createLinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createLinkSync
            <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createReadStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createSymlink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createSymlink
            <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createSymlinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createSymlinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createSymlinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createSymlinkSync
            <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.createWriteStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>createWriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.emptyDir">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptyDir
            <span class="apidocSignatureSpan">(dir, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.emptyDirAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptyDirAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.emptyDirSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptyDirSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.emptydir">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptydir
            <span class="apidocSignatureSpan">(dir, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.emptydirAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptydirAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.emptydirSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptydirSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureDir">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureDir
            <span class="apidocSignatureSpan">(p, opts, callback, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureDirAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureDirAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureDirSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureDirSync
            <span class="apidocSignatureSpan">(p, opts, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureFile
            <span class="apidocSignatureSpan">(file, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureFileAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureFileAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureFileSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureFileSync
            <span class="apidocSignatureSpan">(file)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureLink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureLink
            <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureLinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureLinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureLinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureLinkSync
            <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureSymlink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureSymlink
            <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureSymlinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureSymlinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ensureSymlinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureSymlinkSync
            <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.exists">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>exists
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.existsAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>existsAsync
            <span class="apidocSignatureSpan">(resolve =&#x3e; fs.exists(path, resolve)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.existsSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>existsSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fchmod">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchmod
            <span class="apidocSignatureSpan">(target, mode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fchmodAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchmodAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fchmodSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchmodSync
            <span class="apidocSignatureSpan">(target, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fchown">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchown
            <span class="apidocSignatureSpan">(target, uid, gid, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fchownAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchownAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fchownSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchownSync
            <span class="apidocSignatureSpan">(target, uid, gid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fdatasync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fdatasync
            <span class="apidocSignatureSpan">(fd, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fdatasyncAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fdatasyncAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fdatasyncSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fdatasyncSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fstat">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fstat
            <span class="apidocSignatureSpan">(target, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fstatAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fstatAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fstatSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fstatSync
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fsync
            <span class="apidocSignatureSpan">(fd, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fsyncAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fsyncAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.fsyncSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>fsyncSync
            <span class="apidocSignatureSpan">(fd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ftruncate">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ftruncate
            <span class="apidocSignatureSpan">(fd, len, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ftruncateAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ftruncateAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ftruncateSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ftruncateSync
            <span class="apidocSignatureSpan">(fd, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.futimes">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>futimes
            <span class="apidocSignatureSpan">(fd, atime, mtime, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.futimesAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>futimesAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.futimesSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>futimesSync
            <span class="apidocSignatureSpan">(fd, atime, mtime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.gracefulify">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>gracefulify
            <span class="apidocSignatureSpan">(fs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.gracefulifyAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>gracefulifyAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.isDirectory">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>isDirectory
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.isDirectoryAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>isDirectoryAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.isDirectorySync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>isDirectorySync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lchmod">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchmod
            <span class="apidocSignatureSpan">(path, mode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lchmodAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchmodAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lchmodSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchmodSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lchown">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchown
            <span class="apidocSignatureSpan">(path, uid, gid, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lchownAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchownAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lchownSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchownSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.link">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>link
            <span class="apidocSignatureSpan">(existingPath, newPath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.linkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>linkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.linkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>linkSync
            <span class="apidocSignatureSpan">(existingPath, newPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lstat">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lstat
            <span class="apidocSignatureSpan">(target, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lstatAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lstatAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lstatSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lstatSync
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lutimes">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lutimes
            <span class="apidocSignatureSpan">(_a, _b, _c, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lutimesAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lutimesAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.lutimesSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>lutimesSync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdir">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdir
            <span class="apidocSignatureSpan">(path, mode, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirSync
            <span class="apidocSignatureSpan">(path, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirp">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirp
            <span class="apidocSignatureSpan">(p, opts, callback, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirpAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirpAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirpSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirpSync
            <span class="apidocSignatureSpan">(p, opts, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirs">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirs
            <span class="apidocSignatureSpan">(p, opts, callback, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirsAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirsAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdirsSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirsSync
            <span class="apidocSignatureSpan">(p, opts, made)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdtemp">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdtemp
            <span class="apidocSignatureSpan">(prefix, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdtempAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdtempAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.mkdtempSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdtempSync
            <span class="apidocSignatureSpan">(prefix, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.move">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>move
            <span class="apidocSignatureSpan">(source, dest, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.moveAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>moveAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.moveSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>moveSync
            <span class="apidocSignatureSpan">(src, dest, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.open">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>open
            <span class="apidocSignatureSpan">(path, flags, mode, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.openAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>openAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.openSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>openSync
            <span class="apidocSignatureSpan">(path, flags, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputFile
            <span class="apidocSignatureSpan">(file, data, encoding, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputFileAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputFileAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputFileSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputFileSync
            <span class="apidocSignatureSpan">(file, data, encoding)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputJSON">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJSON
            <span class="apidocSignatureSpan">(file, data, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputJSONAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJSONAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputJSONSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJSONSync
            <span class="apidocSignatureSpan">(file, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputJson">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJson
            <span class="apidocSignatureSpan">(file, data, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputJsonAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJsonAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.outputJsonSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJsonSync
            <span class="apidocSignatureSpan">(file, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.read">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>read
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2, _arg3, _arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readFile
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readFileAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readFileAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readFileSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readFileSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readJSON">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJSON
            <span class="apidocSignatureSpan">(file, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readJSONAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJSONAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readJSONSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJSONSync
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readJson">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJson
            <span class="apidocSignatureSpan">(file, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readJsonAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJsonAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readJsonSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJsonSync
            <span class="apidocSignatureSpan">(file, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readSync
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readdir">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readdir
            <span class="apidocSignatureSpan">(path, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readdirAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readdirAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readdirSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readdirSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readlink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readlink
            <span class="apidocSignatureSpan">(path, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readlinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readlinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.readlinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>readlinkSync
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.realpath">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>realpath
            <span class="apidocSignatureSpan">(p, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.realpathAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>realpathAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.realpathSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>realpathSync
            <span class="apidocSignatureSpan">(p, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.remove">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>remove
            <span class="apidocSignatureSpan">(dir, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.removeAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>removeAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.removeSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>removeSync
            <span class="apidocSignatureSpan">(dir)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.rename">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>rename
            <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.renameAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>renameAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.renameSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>renameSync
            <span class="apidocSignatureSpan">(oldPath, newPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.rmdir">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>rmdir
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.rmdirAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>rmdirAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.rmdirSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>rmdirSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.stat">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>stat
            <span class="apidocSignatureSpan">(target, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.statAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>statAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.statSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>statSync
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.symlink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>symlink
            <span class="apidocSignatureSpan">(target, path, type_, callback_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.symlinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>symlinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.symlinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>symlinkSync
            <span class="apidocSignatureSpan">(target, path, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.truncate">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>truncate
            <span class="apidocSignatureSpan">(path, len, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.truncateAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>truncateAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.truncateSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>truncateSync
            <span class="apidocSignatureSpan">(path, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.unlink">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>unlink
            <span class="apidocSignatureSpan">(path, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.unlinkAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>unlinkAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.unlinkSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>unlinkSync
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.unwatchFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>unwatchFile
            <span class="apidocSignatureSpan">(filename, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.useFs">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>useFs
            <span class="apidocSignatureSpan">(fs, Promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.usePromise">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>usePromise
            <span class="apidocSignatureSpan">(fsOriginal, Promise)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.utimes">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>utimes
            <span class="apidocSignatureSpan">(path, atime, mtime, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.utimesAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>utimesAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.utimesSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>utimesSync
            <span class="apidocSignatureSpan">(path, atime, mtime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.watch">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>watch
            <span class="apidocSignatureSpan">(filename, options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.watchFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>watchFile
            <span class="apidocSignatureSpan">(filename, options, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.write">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>write
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2, _arg3, _arg4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeFile
            <span class="apidocSignatureSpan">(path, data, options, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeFileAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeFileAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeFileSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeFileSync
            <span class="apidocSignatureSpan">(path, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeJSON">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJSON
            <span class="apidocSignatureSpan">(file, obj, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeJSONAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJSONAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeJSONSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJSONSync
            <span class="apidocSignatureSpan">(file, obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeJson">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJson
            <span class="apidocSignatureSpan">(file, obj, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeJsonAsync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJsonAsync
            <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeJsonSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJsonSync
            <span class="apidocSignatureSpan">(file, obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.writeSync">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeSync
            <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fs-extra-promise.</span>F_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fs-extra-promise.</span>R_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fs-extra-promise.</span>W_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fs-extra-promise.</span>X_OK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">fs-extra-promise.</span>spaces</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fs-extra-promise.</span>ReadStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fs-extra-promise.</span>Stats.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fs-extra-promise.</span>WriteStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fs-extra-promise.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">fs-extra-promise.</span>jsonfile</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise.ReadStream">module fs-extra-promise.ReadStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ReadStream.ReadStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>ReadStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise.ReadStream.prototype">module fs-extra-promise.ReadStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.ReadStream.prototype.open">
            function <span class="apidocSignatureSpan">fs-extra-promise.ReadStream.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise.Stats">module fs-extra-promise.Stats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.Stats">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>Stats
            <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise.Stats.prototype">module fs-extra-promise.Stats.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype._checkModeProperty">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>_checkModeProperty
            <span class="apidocSignatureSpan">(property)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isBlockDevice">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isBlockDevice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isCharacterDevice">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isCharacterDevice
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isDirectory">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isFIFO">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isFIFO
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isFile">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isFile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isSocket">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isSocket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.Stats.prototype.isSymbolicLink">
            function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isSymbolicLink
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise.WriteStream">module fs-extra-promise.WriteStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.WriteStream.WriteStream">
            function <span class="apidocSignatureSpan">fs-extra-promise.</span>WriteStream
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.fs-extra-promise.WriteStream.prototype">module fs-extra-promise.WriteStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.fs-extra-promise.WriteStream.prototype.open">
            function <span class="apidocSignatureSpan">fs-extra-promise.WriteStream.prototype.</span>open
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise" id="apidoc.module.fs-extra-promise">module fs-extra-promise</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.FileReadStream" id="apidoc.element.fs-extra-promise.FileReadStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>FileReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (this instanceof ReadStream)
    return fs$ReadStream.apply(this, arguments), this
  else
    return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.FileWriteStream" id="apidoc.element.fs-extra-promise.FileWriteStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>FileWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (this instanceof WriteStream)
    return fs$WriteStream.apply(this, arguments), this
  else
    return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ReadStream" id="apidoc.element.fs-extra-promise.ReadStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (this instanceof ReadStream)
    return fs$ReadStream.apply(this, arguments), this
  else
    return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats" id="apidoc.element.fs-extra-promise.Stats">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>Stats
        <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.WriteStream" id="apidoc.element.fs-extra-promise.WriteStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>WriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (this instanceof WriteStream)
    return fs$WriteStream.apply(this, arguments), this
  else
    return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise._toUnixTimestamp" id="apidoc.element.fs-extra-promise._toUnixTimestamp">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>_toUnixTimestamp
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUnixTimestamp(time) {
  if (typeof time === &#x27;string&#x27; &#x26;&#x26; +time == time) {
    return +time;
  }
  if (typeof time === &#x27;number&#x27;) {
    if (!Number.isFinite(time) || time &#x3c; 0) {
      return Date.now() / 1000;
    }
    return time;
  }
  if (util.isDate(time)) {
    // convert to 123.456 UNIX timestamp
    return time.getTime() / 1000;
  }
  throw new Error(&#x27;Cannot parse time: &#x27; + time);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise._toUnixTimestampAsync" id="apidoc.element.fs-extra-promise._toUnixTimestampAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>_toUnixTimestampAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_toUnixTimestampAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.access" id="apidoc.element.fs-extra-promise.access">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>access
        <span class="apidocSignatureSpan">(path, mode, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">access = function (path, mode, callback) {
  if (typeof mode === &#x27;function&#x27;) {
    callback = mode;
    mode = fs.F_OK;
  } else if (typeof callback !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;&#x22;callback&#x22; argument must be a function&#x27;);
  }

  if (!nullCheck(path, callback))
    return;

  mode = mode | 0;
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.access(pathModule._makeLong(path), mode, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.accessAsync" id="apidoc.element.fs-extra-promise.accessAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>accessAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accessAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.accessSync" id="apidoc.element.fs-extra-promise.accessSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>accessSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">accessSync = function (path, mode) {
  nullCheck(path);

  if (mode === undefined)
    mode = fs.F_OK;
  else
    mode = mode | 0;

  binding.access(pathModule._makeLong(path), mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.appendFile" id="apidoc.element.fs-extra-promise.appendFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>appendFile
        <span class="apidocSignatureSpan">(path, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function appendFile(path, data, options, cb) {
  if (typeof options === &#x27;function&#x27;)
    cb = options, options = null

  return go$appendFile(path, data, options, cb)

  function go$appendFile (path, data, options, cb) {
    return fs$appendFile(path, data, options, function (err) {
      if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
        enqueue([go$appendFile, [path, data, options, cb]])
      else {
        if (typeof cb === &#x27;function&#x27;)
          cb.apply(this, arguments)
        retry()
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.appendFileAsync" id="apidoc.element.fs-extra-promise.appendFileAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>appendFileAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFileAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.appendFileSync" id="apidoc.element.fs-extra-promise.appendFileSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>appendFileSync
        <span class="apidocSignatureSpan">(path, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">appendFileSync = function (path, data, options) {
  if (!options) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;a&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  if (!options.flag)
    options = util._extend({ flag: &#x27;a&#x27; }, options);

  // force append behavior when using a supplied file descriptor
  if (isFd(path))
    options.flag = &#x27;a&#x27;;

  fs.writeFileSync(path, data, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.chmod" id="apidoc.element.fs-extra-promise.chmod">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>chmod
        <span class="apidocSignatureSpan">(target, mode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmod = function (target, mode, cb) {
  return orig.call(fs, target, mode, function (er) {
    if (chownErOk(er)) er = null
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.chmodAsync" id="apidoc.element.fs-extra-promise.chmodAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>chmodAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmodAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.chmodSync" id="apidoc.element.fs-extra-promise.chmodSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>chmodSync
        <span class="apidocSignatureSpan">(target, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chmodSync = function (target, mode) {
  try {
    return orig.call(fs, target, mode)
  } catch (er) {
    if (!chownErOk(er)) throw er
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.chown" id="apidoc.element.fs-extra-promise.chown">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>chown
        <span class="apidocSignatureSpan">(target, uid, gid, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chown = function (target, uid, gid, cb) {
  return orig.call(fs, target, uid, gid, function (er) {
    if (chownErOk(er)) er = null
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.chownAsync" id="apidoc.element.fs-extra-promise.chownAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>chownAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chownAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.chownSync" id="apidoc.element.fs-extra-promise.chownSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>chownSync
        <span class="apidocSignatureSpan">(target, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chownSync = function (target, uid, gid) {
  try {
    return orig.call(fs, target, uid, gid)
  } catch (er) {
    if (!chownErOk(er)) throw er
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.close" id="apidoc.element.fs-extra-promise.close">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>close
        <span class="apidocSignatureSpan">(fd, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (fd, cb) {
  return fs$close.call(fs, fd, function (err) {
    if (!err)
      retry()

    if (typeof cb === &#x27;function&#x27;)
      cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.closeAsync" id="apidoc.element.fs-extra-promise.closeAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>closeAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.closeSync" id="apidoc.element.fs-extra-promise.closeSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>closeSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closeSync = function (fd) {
  // Note that graceful-fs also retries when fs.closeSync() fails.
  // Looks like a bug to me, although it&#x27;s probably a harmless one.
  var rval = fs$closeSync.apply(fs, arguments)
  retry()
  return rval
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.copy" id="apidoc.element.fs-extra-promise.copy">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>copy
        <span class="apidocSignatureSpan">(src, dest, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copy(src, dest, options, callback) {
  if (typeof options === &#x27;function&#x27; &#x26;&#x26; !callback) {
    callback = options
    options = {}
  } else if (typeof options === &#x27;function&#x27; || options instanceof RegExp) {
    options = {filter: options}
  }
  callback = callback || function () {}
  options = options || {}

  // Warn about using preserveTimestamps on 32-bit node:
  if (options.preserveTimestamps &#x26;&#x26; process.arch === &#x27;ia32&#x27;) {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  // don&#x27;t allow src and dest to be the same
  const basePath = process.cwd()
  const currentPath = path.resolve(basePath, src)
  const targetPath = path.resolve(basePath, dest)
  if (currentPath === targetPath) return callback(new Error(&#x27;Source and destination must not be the same.&#x27;))

  fs.lstat(src, (err, stats) =&#x3e; {
    if (err) return callback(err)

    let dir = null
    if (stats.isDirectory()) {
      const parts = dest.split(path.sep)
      parts.pop()
      dir = parts.join(path.sep)
    } else {
      dir = path.dirname(dest)
    }

    fs.exists(dir, dirExists =&#x3e; {
      if (dirExists) return ncp(src, dest, options, callback)
      mkdir.mkdirs(dir, err =&#x3e; {
        if (err) return callback(err)
        ncp(src, dest, options, callback)
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.copyAsync" id="apidoc.element.fs-extra-promise.copyAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>copyAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copyAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.copySync" id="apidoc.element.fs-extra-promise.copySync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>copySync
        <span class="apidocSignatureSpan">(src, dest, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copySync(src, dest, options) {
  if (typeof options === &#x27;function&#x27; || options instanceof RegExp) {
    options = {filter: options}
  }

  options = options || {}
  options.recursive = !!options.recursive

  // default to true for now
  options.clobber = &#x27;clobber&#x27; in options ? !!options.clobber : true
  // overwrite falls back to clobber
  options.overwrite = &#x27;overwrite&#x27; in options ? !!options.overwrite : options.clobber
  options.dereference = &#x27;dereference&#x27; in options ? !!options.dereference : false
  options.preserveTimestamps = &#x27;preserveTimestamps&#x27; in options ? !!options.preserveTimestamps : false

  options.filter = options.filter || function () { return true }

  // Warn about using preserveTimestamps on 32-bit node:
  if (options.preserveTimestamps &#x26;&#x26; process.arch === &#x27;ia32&#x27;) {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  const stats = (options.recursive &#x26;&#x26; !options.dereference) ? fs.lstatSync(src) : fs.statSync(src)
  const destFolder = path.dirname(dest)
  const destFolderExists = fs.existsSync(destFolder)
  let performCopy = false

  if (options.filter instanceof RegExp) {
    console.warn(&#x27;Warning: fs-extra: Passing a RegExp filter is deprecated, use a function&#x27;)
    performCopy = options.filter.test(src)
  } else if (typeof options.filter === &#x27;function&#x27;) performCopy = options.filter(src, dest)

  if (stats.isFile() &#x26;&#x26; performCopy) {
    if (!destFolderExists) mkdir.mkdirsSync(destFolder)
    copyFileSync(src, dest, {
      overwrite: options.overwrite,
      errorOnExist: options.errorOnExist,
      preserveTimestamps: options.preserveTimestamps
    })
  } else if (stats.isDirectory() &#x26;&#x26; performCopy) {
    if (!fs.existsSync(dest)) mkdir.mkdirsSync(dest)
    const contents = fs.readdirSync(src)
    contents.forEach(content =&#x3e; {
      const opts = options
      opts.recursive = true
      copySync(path.join(src, content), path.join(dest, content), opts)
    })
  } else if (options.recursive &#x26;&#x26; stats.isSymbolicLink() &#x26;&#x26; performCopy) {
    const srcPath = fs.readlinkSync(src)
    fs.symlinkSync(srcPath, dest)
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createFile" id="apidoc.element.fs-extra-promise.createFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createFile
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFile(file, callback) {
  function makeFile () {
    fs.writeFile(file, &#x27;&#x27;, err =&#x3e; {
      if (err) return callback(err)
      callback()
    })
  }

  fs.exists(file, fileExists =&#x3e; {
    if (fileExists) return callback()
    const dir = path.dirname(file)
    fs.exists(dir, dirExists =&#x3e; {
      if (dirExists) return makeFile()
      mkdir.mkdirs(dir, err =&#x3e; {
        if (err) return callback(err)
        makeFile()
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createFileAsync" id="apidoc.element.fs-extra-promise.createFileAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createFileAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createFileAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createFileSync" id="apidoc.element.fs-extra-promise.createFileSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createFileSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFileSync(file) {
  if (fs.existsSync(file)) return

  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, &#x27;&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createLink" id="apidoc.element.fs-extra-promise.createLink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createLink
        <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLink(srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err =&#x3e; {
      if (err) return callback(err)
      callback(null)
    })
  }

  fs.exists(dstpath, destinationExists =&#x3e; {
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err, stat) =&#x3e; {
      if (err) {
        err.message = err.message.replace(&#x27;lstat&#x27;, &#x27;ensureLink&#x27;)
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      fs.exists(dir, dirExists =&#x3e; {
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err =&#x3e; {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createLinkAsync" id="apidoc.element.fs-extra-promise.createLinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createLinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createLinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createLinkSync" id="apidoc.element.fs-extra-promise.createLinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createLinkSync
        <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLinkSync(srcpath, dstpath, callback) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace(&#x27;lstat&#x27;, &#x27;ensureLink&#x27;)
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createReadStream" id="apidoc.element.fs-extra-promise.createReadStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createReadStream(path, options) {
  return new ReadStream(path, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createSymlink" id="apidoc.element.fs-extra-promise.createSymlink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createSymlink
        <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSymlink(srcpath, dstpath, type, callback) {
  callback = (typeof type === &#x27;function&#x27;) ? type : callback
  type = (typeof type === &#x27;function&#x27;) ? false : type

  fs.exists(dstpath, destinationExists =&#x3e; {
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) =&#x3e; {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) =&#x3e; {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        fs.exists(dir, dirExists =&#x3e; {
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err =&#x3e; {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createSymlinkAsync" id="apidoc.element.fs-extra-promise.createSymlinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createSymlinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSymlinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createSymlinkSync" id="apidoc.element.fs-extra-promise.createSymlinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createSymlinkSync
        <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSymlinkSync(srcpath, dstpath, type, callback) {
  callback = (typeof type === &#x27;function&#x27;) ? type : callback
  type = (typeof type === &#x27;function&#x27;) ? false : type

  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.createWriteStream" id="apidoc.element.fs-extra-promise.createWriteStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>createWriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createWriteStream(path, options) {
  return new WriteStream(path, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.emptyDir" id="apidoc.element.fs-extra-promise.emptyDir">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptyDir
        <span class="apidocSignatureSpan">(dir, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emptyDir(dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) =&#x3e; {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item =&#x3e; path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err =&#x3e; {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.emptyDirAsync" id="apidoc.element.fs-extra-promise.emptyDirAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptyDirAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyDirAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.emptyDirSync" id="apidoc.element.fs-extra-promise.emptyDirSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptyDirSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emptyDirSync(dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch (err) {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item =&#x3e; {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.emptydir" id="apidoc.element.fs-extra-promise.emptydir">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptydir
        <span class="apidocSignatureSpan">(dir, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emptyDir(dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) =&#x3e; {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item =&#x3e; path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err =&#x3e; {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.emptydirAsync" id="apidoc.element.fs-extra-promise.emptydirAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptydirAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptydirAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.emptydirSync" id="apidoc.element.fs-extra-promise.emptydirSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>emptydirSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emptyDirSync(dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch (err) {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item =&#x3e; {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureDir" id="apidoc.element.fs-extra-promise.ensureDir">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureDir
        <span class="apidocSignatureSpan">(p, opts, callback, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirs(p, opts, callback, made) {
  if (typeof opts === &#x27;function&#x27;) {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== &#x27;object&#x27;) {
    opts = { mode: opts }
  }

  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; invalidWin32Path(p)) {
    const errInval = new Error(p + &#x27; contains invalid WIN32 path characters.&#x27;)
    errInval.code = &#x27;EINVAL&#x27;
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 &#x26; (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er =&#x3e; {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case &#x27;ENOENT&#x27;:
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) =&#x3e; {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there&#x27;s a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) =&#x3e; {
          // if the stat fails, then that&#x27;s super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureDirAsync" id="apidoc.element.fs-extra-promise.ensureDirAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureDirAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureDirAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureDirSync" id="apidoc.element.fs-extra-promise.ensureDirSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureDirSync
        <span class="apidocSignatureSpan">(p, opts, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirsSync(p, opts, made) {
  if (!opts || typeof opts !== &#x27;object&#x27;) {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; invalidWin32Path(p)) {
    const errInval = new Error(p + &#x27; contains invalid WIN32 path characters.&#x27;)
    errInval.code = &#x27;EINVAL&#x27;
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 &#x26; (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    switch (err0.code) {
      case &#x27;ENOENT&#x27;:
        if (path.dirname(p) === p) throw err0
        made = mkdirsSync(path.dirname(p), opts, made)
        mkdirsSync(p, opts, made)
        break

      // In the case of any other error, just see if there&#x27;s a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat
        try {
          stat = xfs.statSync(p)
        } catch (err1) {
          throw err0
        }
        if (!stat.isDirectory()) throw err0
        break
    }
  }

  return made
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureFile" id="apidoc.element.fs-extra-promise.ensureFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureFile
        <span class="apidocSignatureSpan">(file, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFile(file, callback) {
  function makeFile () {
    fs.writeFile(file, &#x27;&#x27;, err =&#x3e; {
      if (err) return callback(err)
      callback()
    })
  }

  fs.exists(file, fileExists =&#x3e; {
    if (fileExists) return callback()
    const dir = path.dirname(file)
    fs.exists(dir, dirExists =&#x3e; {
      if (dirExists) return makeFile()
      mkdir.mkdirs(dir, err =&#x3e; {
        if (err) return callback(err)
        makeFile()
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureFileAsync" id="apidoc.element.fs-extra-promise.ensureFileAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureFileAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureFileAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureFileSync" id="apidoc.element.fs-extra-promise.ensureFileSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureFileSync
        <span class="apidocSignatureSpan">(file)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createFileSync(file) {
  if (fs.existsSync(file)) return

  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, &#x27;&#x27;)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureLink" id="apidoc.element.fs-extra-promise.ensureLink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureLink
        <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLink(srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err =&#x3e; {
      if (err) return callback(err)
      callback(null)
    })
  }

  fs.exists(dstpath, destinationExists =&#x3e; {
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err, stat) =&#x3e; {
      if (err) {
        err.message = err.message.replace(&#x27;lstat&#x27;, &#x27;ensureLink&#x27;)
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      fs.exists(dir, dirExists =&#x3e; {
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err =&#x3e; {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureLinkAsync" id="apidoc.element.fs-extra-promise.ensureLinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureLinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureLinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureLinkSync" id="apidoc.element.fs-extra-promise.ensureLinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureLinkSync
        <span class="apidocSignatureSpan">(srcpath, dstpath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLinkSync(srcpath, dstpath, callback) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace(&#x27;lstat&#x27;, &#x27;ensureLink&#x27;)
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureSymlink" id="apidoc.element.fs-extra-promise.ensureSymlink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureSymlink
        <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSymlink(srcpath, dstpath, type, callback) {
  callback = (typeof type === &#x27;function&#x27;) ? type : callback
  type = (typeof type === &#x27;function&#x27;) ? false : type

  fs.exists(dstpath, destinationExists =&#x3e; {
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) =&#x3e; {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) =&#x3e; {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        fs.exists(dir, dirExists =&#x3e; {
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err =&#x3e; {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureSymlinkAsync" id="apidoc.element.fs-extra-promise.ensureSymlinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureSymlinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureSymlinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ensureSymlinkSync" id="apidoc.element.fs-extra-promise.ensureSymlinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ensureSymlinkSync
        <span class="apidocSignatureSpan">(srcpath, dstpath, type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createSymlinkSync(srcpath, dstpath, type, callback) {
  callback = (typeof type === &#x27;function&#x27;) ? type : callback
  type = (typeof type === &#x27;function&#x27;) ? false : type

  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.exists" id="apidoc.element.fs-extra-promise.exists">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>exists
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exists = function (path, callback) {
  if (!nullCheck(path, cb)) return;
  var req = new FSReqWrap();
  req.oncomplete = cb;
  binding.stat(pathModule._makeLong(path), req);
  function cb(err, stats) {
    if (callback) callback(err ? false : true);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.existsAsync" id="apidoc.element.fs-extra-promise.existsAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>existsAsync
        <span class="apidocSignatureSpan">(resolve =&#x3e; fs.exists(path, resolve)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path =&#x3e; new Promise(resolve =&#x3e; fs.exists(path, resolve))</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.existsSync" id="apidoc.element.fs-extra-promise.existsSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>existsSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsSync = function (path) {
  try {
    nullCheck(path);
    binding.stat(pathModule._makeLong(path), statValues);
    return true;
  } catch (e) {
    return false;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fchmod" id="apidoc.element.fs-extra-promise.fchmod">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchmod
        <span class="apidocSignatureSpan">(target, mode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmod = function (target, mode, cb) {
  return orig.call(fs, target, mode, function (er) {
    if (chownErOk(er)) er = null
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fchmodAsync" id="apidoc.element.fs-extra-promise.fchmodAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchmodAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmodAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fchmodSync" id="apidoc.element.fs-extra-promise.fchmodSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchmodSync
        <span class="apidocSignatureSpan">(target, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchmodSync = function (target, mode) {
  try {
    return orig.call(fs, target, mode)
  } catch (er) {
    if (!chownErOk(er)) throw er
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fchown" id="apidoc.element.fs-extra-promise.fchown">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchown
        <span class="apidocSignatureSpan">(target, uid, gid, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchown = function (target, uid, gid, cb) {
  return orig.call(fs, target, uid, gid, function (er) {
    if (chownErOk(er)) er = null
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fchownAsync" id="apidoc.element.fs-extra-promise.fchownAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchownAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchownAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fchownSync" id="apidoc.element.fs-extra-promise.fchownSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fchownSync
        <span class="apidocSignatureSpan">(target, uid, gid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fchownSync = function (target, uid, gid) {
  try {
    return orig.call(fs, target, uid, gid)
  } catch (er) {
    if (!chownErOk(er)) throw er
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fdatasync" id="apidoc.element.fs-extra-promise.fdatasync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fdatasync
        <span class="apidocSignatureSpan">(fd, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasync = function (fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fdatasync(fd, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fdatasyncAsync" id="apidoc.element.fs-extra-promise.fdatasyncAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fdatasyncAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasyncAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fdatasyncSync" id="apidoc.element.fs-extra-promise.fdatasyncSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fdatasyncSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fdatasyncSync = function (fd) {
  return binding.fdatasync(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fstat" id="apidoc.element.fs-extra-promise.fstat">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fstat
        <span class="apidocSignatureSpan">(target, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstat = function (target, cb) {
  return orig.call(fs, target, function (er, stats) {
    if (!stats) return cb.apply(this, arguments)
    if (stats.uid &#x3c; 0) stats.uid += 0x100000000
    if (stats.gid &#x3c; 0) stats.gid += 0x100000000
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fstatAsync" id="apidoc.element.fs-extra-promise.fstatAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fstatAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstatAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fstatSync" id="apidoc.element.fs-extra-promise.fstatSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fstatSync
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fstatSync = function (target) {
  var stats = orig.call(fs, target)
  if (stats.uid &#x3c; 0) stats.uid += 0x100000000
  if (stats.gid &#x3c; 0) stats.gid += 0x100000000
  return stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fsync" id="apidoc.element.fs-extra-promise.fsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fsync
        <span class="apidocSignatureSpan">(fd, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsync = function (fd, callback) {
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.fsync(fd, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fsyncAsync" id="apidoc.element.fs-extra-promise.fsyncAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fsyncAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsyncAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.fsyncSync" id="apidoc.element.fs-extra-promise.fsyncSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>fsyncSync
        <span class="apidocSignatureSpan">(fd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fsyncSync = function (fd) {
  return binding.fsync(fd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ftruncate" id="apidoc.element.fs-extra-promise.ftruncate">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ftruncate
        <span class="apidocSignatureSpan">(fd, len, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncate = function (fd, len, callback) {
  if (typeof len === &#x27;function&#x27;) {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  }
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.ftruncate(fd, len, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ftruncateAsync" id="apidoc.element.fs-extra-promise.ftruncateAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ftruncateAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncateAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.ftruncateSync" id="apidoc.element.fs-extra-promise.ftruncateSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ftruncateSync
        <span class="apidocSignatureSpan">(fd, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ftruncateSync = function (fd, len) {
  if (len === undefined) {
    len = 0;
  }
  return binding.ftruncate(fd, len);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.futimes" id="apidoc.element.fs-extra-promise.futimes">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>futimes
        <span class="apidocSignatureSpan">(fd, atime, mtime, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimes = function (fd, atime, mtime, callback) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  var req = new FSReqWrap();
  req.oncomplete = makeCallback(callback);
  binding.futimes(fd, atime, mtime, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.futimesAsync" id="apidoc.element.fs-extra-promise.futimesAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>futimesAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimesAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.futimesSync" id="apidoc.element.fs-extra-promise.futimesSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>futimesSync
        <span class="apidocSignatureSpan">(fd, atime, mtime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">futimesSync = function (fd, atime, mtime) {
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.futimes(fd, atime, mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.gracefulify" id="apidoc.element.fs-extra-promise.gracefulify">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>gracefulify
        <span class="apidocSignatureSpan">(fs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function patch(fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch
  fs.FileReadStream = ReadStream;  // Legacy name.
  fs.FileWriteStream = WriteStream;  // Legacy name.
  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === &#x27;function&#x27;)
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb) {
      return fs$readFile(path, options, function (err) {
        if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
          enqueue([go$readFile, [path, options, cb]])
        else {
          if (typeof cb === &#x27;function&#x27;)
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === &#x27;function&#x27;)
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb) {
      return fs$writeFile(path, data, options, function (err) {
        if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
          enqueue([go$writeFile, [path, data, options, cb]])
        else {
          if (typeof cb === &#x27;function&#x27;)
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === &#x27;function&#x27;)
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb) {
      return fs$appendFile(path, data, options, function (err) {
        if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
          enqueue([go$appendFile, [path, data, options, cb]])
        else {
          if (typeof cb === &#x27;function&#x27;)
            cb.apply(this, arguments)
          retry()
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  function readdir (path, options, cb) {
    var args = [path]
    if (typeof options !== &#x27;function&#x27;) {
      args.push(options)
    } else {
      cb = options
    }
    args.push(go$readdir$cb)

    return go$readdir(args)

    function go$readdir$cb (err, files) {
      if (files &#x26;&#x26; files.sort)
        files.sort()

      if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
        enqueue([go$readdir, [args]])
      else {
        if (typeof cb === &#x27;function&#x27;)
          cb.apply(this, arguments)
        retry()
      }
    }
  }

  function go$readdir (args) {
    return fs$readdir.apply(fs, args)
  }

  if (process.version.substr(0, 4) === &#x27;v0.8&#x27;) {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
  ReadStream.prototype.open = ReadStream$open

  var fs$WriteStream = fs.WriteStream
  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
  WriteStream.prototype.open = WriteStream$open

  fs.ReadStream = ReadStream
  fs.WriteStream = WriteStream

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit(&#x27;error&#x27;, err)
      } else {
        that.fd = fd
        that.emit(&#x27;open&#x27;, fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return W ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.gracefulifyAsync" id="apidoc.element.fs-extra-promise.gracefulifyAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>gracefulifyAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gracefulifyAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 0:ret = callback.call(this, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.isDirectory" id="apidoc.element.fs-extra-promise.isDirectory">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>isDirectory
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">(path, callback) =&#x3e; {
		fs.stat(path, (err, stats) =&#x3e; {
			if (err) {
				callback(err);
			} else {
				callback(null, stats.isDirectory());
			}
		});
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.isDirectoryAsync" id="apidoc.element.fs-extra-promise.isDirectoryAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>isDirectoryAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectoryAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.isDirectorySync" id="apidoc.element.fs-extra-promise.isDirectorySync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>isDirectorySync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path =&#x3e; fs.statSync(path).isDirectory()</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lchmod" id="apidoc.element.fs-extra-promise.lchmod">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchmod
        <span class="apidocSignatureSpan">(path, mode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lchmod = function (path, mode, cb) {
  if (cb) process.nextTick(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lchmodAsync" id="apidoc.element.fs-extra-promise.lchmodAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchmodAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lchmodAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lchmodSync" id="apidoc.element.fs-extra-promise.lchmodSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchmodSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lchmodSync = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lchown" id="apidoc.element.fs-extra-promise.lchown">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchown
        <span class="apidocSignatureSpan">(path, uid, gid, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lchown = function (path, uid, gid, cb) {
  if (cb) process.nextTick(cb)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lchownAsync" id="apidoc.element.fs-extra-promise.lchownAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchownAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lchownAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lchownSync" id="apidoc.element.fs-extra-promise.lchownSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lchownSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lchownSync = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.link" id="apidoc.element.fs-extra-promise.link">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>link
        <span class="apidocSignatureSpan">(existingPath, newPath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">link = function (existingPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(existingPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.link(pathModule._makeLong(existingPath),
               pathModule._makeLong(newPath),
               req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.linkAsync" id="apidoc.element.fs-extra-promise.linkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>linkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.linkSync" id="apidoc.element.fs-extra-promise.linkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>linkSync
        <span class="apidocSignatureSpan">(existingPath, newPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linkSync = function (existingPath, newPath) {
  nullCheck(existingPath);
  nullCheck(newPath);
  return binding.link(pathModule._makeLong(existingPath),
                      pathModule._makeLong(newPath));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lstat" id="apidoc.element.fs-extra-promise.lstat">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lstat
        <span class="apidocSignatureSpan">(target, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstat = function (target, cb) {
  return orig.call(fs, target, function (er, stats) {
    if (!stats) return cb.apply(this, arguments)
    if (stats.uid &#x3c; 0) stats.uid += 0x100000000
    if (stats.gid &#x3c; 0) stats.gid += 0x100000000
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lstatAsync" id="apidoc.element.fs-extra-promise.lstatAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lstatAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstatAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lstatSync" id="apidoc.element.fs-extra-promise.lstatSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lstatSync
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lstatSync = function (target) {
  var stats = orig.call(fs, target)
  if (stats.uid &#x3c; 0) stats.uid += 0x100000000
  if (stats.gid &#x3c; 0) stats.gid += 0x100000000
  return stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lutimes" id="apidoc.element.fs-extra-promise.lutimes">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lutimes
        <span class="apidocSignatureSpan">(_a, _b, _c, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lutimesAsync" id="apidoc.element.fs-extra-promise.lutimesAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lutimesAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lutimesAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.lutimesSync" id="apidoc.element.fs-extra-promise.lutimesSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>lutimesSync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lutimesSync = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdir" id="apidoc.element.fs-extra-promise.mkdir">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdir
        <span class="apidocSignatureSpan">(path, mode, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdir = function (path, mode, callback) {
  if (typeof mode === &#x27;function&#x27;) callback = mode;
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.mkdir(pathModule._makeLong(path),
                modeNum(mode, 0o777),
                req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirAsync" id="apidoc.element.fs-extra-promise.mkdirAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirSync" id="apidoc.element.fs-extra-promise.mkdirSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirSync
        <span class="apidocSignatureSpan">(path, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirSync = function (path, mode) {
  nullCheck(path);
  return binding.mkdir(pathModule._makeLong(path),
                       modeNum(mode, 0o777));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirp" id="apidoc.element.fs-extra-promise.mkdirp">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirp
        <span class="apidocSignatureSpan">(p, opts, callback, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirs(p, opts, callback, made) {
  if (typeof opts === &#x27;function&#x27;) {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== &#x27;object&#x27;) {
    opts = { mode: opts }
  }

  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; invalidWin32Path(p)) {
    const errInval = new Error(p + &#x27; contains invalid WIN32 path characters.&#x27;)
    errInval.code = &#x27;EINVAL&#x27;
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 &#x26; (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er =&#x3e; {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case &#x27;ENOENT&#x27;:
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) =&#x3e; {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there&#x27;s a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) =&#x3e; {
          // if the stat fails, then that&#x27;s super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirpAsync" id="apidoc.element.fs-extra-promise.mkdirpAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirpAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirpAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirpSync" id="apidoc.element.fs-extra-promise.mkdirpSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirpSync
        <span class="apidocSignatureSpan">(p, opts, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirsSync(p, opts, made) {
  if (!opts || typeof opts !== &#x27;object&#x27;) {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; invalidWin32Path(p)) {
    const errInval = new Error(p + &#x27; contains invalid WIN32 path characters.&#x27;)
    errInval.code = &#x27;EINVAL&#x27;
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 &#x26; (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    switch (err0.code) {
      case &#x27;ENOENT&#x27;:
        if (path.dirname(p) === p) throw err0
        made = mkdirsSync(path.dirname(p), opts, made)
        mkdirsSync(p, opts, made)
        break

      // In the case of any other error, just see if there&#x27;s a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat
        try {
          stat = xfs.statSync(p)
        } catch (err1) {
          throw err0
        }
        if (!stat.isDirectory()) throw err0
        break
    }
  }

  return made
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirs" id="apidoc.element.fs-extra-promise.mkdirs">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirs
        <span class="apidocSignatureSpan">(p, opts, callback, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirs(p, opts, callback, made) {
  if (typeof opts === &#x27;function&#x27;) {
    callback = opts
    opts = {}
  } else if (!opts || typeof opts !== &#x27;object&#x27;) {
    opts = { mode: opts }
  }

  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; invalidWin32Path(p)) {
    const errInval = new Error(p + &#x27; contains invalid WIN32 path characters.&#x27;)
    errInval.code = &#x27;EINVAL&#x27;
    return callback(errInval)
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (mode === undefined) {
    mode = o777 &#x26; (~process.umask())
  }
  if (!made) made = null

  callback = callback || function () {}
  p = path.resolve(p)

  xfs.mkdir(p, mode, er =&#x3e; {
    if (!er) {
      made = made || p
      return callback(null, made)
    }
    switch (er.code) {
      case &#x27;ENOENT&#x27;:
        if (path.dirname(p) === p) return callback(er)
        mkdirs(path.dirname(p), opts, (er, made) =&#x3e; {
          if (er) callback(er, made)
          else mkdirs(p, opts, callback, made)
        })
        break

      // In the case of any other error, just see if there&#x27;s a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        xfs.stat(p, (er2, stat) =&#x3e; {
          // if the stat fails, then that&#x27;s super weird.
          // let the original error be the failure reason.
          if (er2 || !stat.isDirectory()) callback(er, made)
          else callback(null, made)
        })
        break
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirsAsync" id="apidoc.element.fs-extra-promise.mkdirsAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirsAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdirsAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdirsSync" id="apidoc.element.fs-extra-promise.mkdirsSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdirsSync
        <span class="apidocSignatureSpan">(p, opts, made)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mkdirsSync(p, opts, made) {
  if (!opts || typeof opts !== &#x27;object&#x27;) {
    opts = { mode: opts }
  }

  let mode = opts.mode
  const xfs = opts.fs || fs

  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; invalidWin32Path(p)) {
    const errInval = new Error(p + &#x27; contains invalid WIN32 path characters.&#x27;)
    errInval.code = &#x27;EINVAL&#x27;
    throw errInval
  }

  if (mode === undefined) {
    mode = o777 &#x26; (~process.umask())
  }
  if (!made) made = null

  p = path.resolve(p)

  try {
    xfs.mkdirSync(p, mode)
    made = made || p
  } catch (err0) {
    switch (err0.code) {
      case &#x27;ENOENT&#x27;:
        if (path.dirname(p) === p) throw err0
        made = mkdirsSync(path.dirname(p), opts, made)
        mkdirsSync(p, opts, made)
        break

      // In the case of any other error, just see if there&#x27;s a dir
      // there already.  If so, then hooray!  If not, then something
      // is borked.
      default:
        let stat
        try {
          stat = xfs.statSync(p)
        } catch (err1) {
          throw err0
        }
        if (!stat.isDirectory()) throw err0
        break
    }
  }

  return made
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdtemp" id="apidoc.element.fs-extra-promise.mkdtemp">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdtemp
        <span class="apidocSignatureSpan">(prefix, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtemp = function (prefix, options, callback) {
  if (!prefix || typeof prefix !== &#x27;string&#x27;)
    throw new TypeError(&#x27;filename prefix is required&#x27;);

  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);

  callback = makeCallback(callback);
  if (!nullCheck(prefix, callback)) {
    return;
  }

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.mkdtemp(prefix + &#x27;XXXXXX&#x27;, options.encoding, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdtempAsync" id="apidoc.element.fs-extra-promise.mkdtempAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdtempAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtempAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.mkdtempSync" id="apidoc.element.fs-extra-promise.mkdtempSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>mkdtempSync
        <span class="apidocSignatureSpan">(prefix, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mkdtempSync = function (prefix, options) {
  if (!prefix || typeof prefix !== &#x27;string&#x27;)
    throw new TypeError(&#x27;filename prefix is required&#x27;);

  options = options || {};
  if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(prefix);

  return binding.mkdtemp(prefix + &#x27;XXXXXX&#x27;, options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.move" id="apidoc.element.fs-extra-promise.move">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>move
        <span class="apidocSignatureSpan">(source, dest, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function move(source, dest, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options
    options = {}
  }

  const shouldMkdirp = (&#x27;mkdirp&#x27; in options) ? options.mkdirp : true
  const overwrite = options.overwrite || options.clobber || false

  if (shouldMkdirp) {
    mkdirs()
  } else {
    doRename()
  }

  function mkdirs () {
    mkdirp(path.dirname(dest), err =&#x3e; {
      if (err) return callback(err)
      doRename()
    })
  }

  function doRename () {
    if (path.resolve(source) === path.resolve(dest)) {
      setImmediate(callback)
    } else if (overwrite) {
      fs.rename(source, dest, err =&#x3e; {
        if (!err) return callback()

        if (err.code === &#x27;ENOTEMPTY&#x27; || err.code === &#x27;EEXIST&#x27;) {
          remove(dest, err =&#x3e; {
            if (err) return callback(err)
            options.overwrite = false // just overwriteed it, no need to do it again
            move(source, dest, options, callback)
          })
          return
        }

        // weird Windows shit
        if (err.code === &#x27;EPERM&#x27;) {
          setTimeout(() =&#x3e; {
            remove(dest, err =&#x3e; {
              if (err) return callback(err)
              options.overwrite = false
              move(source, dest, options, callback)
            })
          }, 200)
          return
        }

        if (err.code !== &#x27;EXDEV&#x27;) return callback(err)
        moveAcrossDevice(source, dest, overwrite, callback)
      })
    } else {
      fs.link(source, dest, err =&#x3e; {
        if (err) {
          if (err.code === &#x27;EXDEV&#x27; || err.code === &#x27;EISDIR&#x27; || err.code === &#x27;EPERM&#x27; || err.code === &#x27;ENOTSUP&#x27;) {
            moveAcrossDevice(source, dest, overwrite, callback)
            return
          }
          callback(err)
          return
        }
        fs.unlink(source, callback)
      })
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.moveAsync" id="apidoc.element.fs-extra-promise.moveAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>moveAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.moveSync" id="apidoc.element.fs-extra-promise.moveSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>moveSync
        <span class="apidocSignatureSpan">(src, dest, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveSync(src, dest, options) {
  options = options || {}
  const overwrite = options.overwrite || options.clobber || false

  src = path.resolve(src)
  dest = path.resolve(dest)

  if (src === dest) return

  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move &#x27;${src}&#x27; into itself &#x27;${dest}&#x27;.`)

  mkdirpSync(path.dirname(dest))
  tryRenameSync()

  function tryRenameSync () {
    if (overwrite) {
      try {
        return fs.renameSync(src, dest)
      } catch (err) {
        if (err.code === &#x27;ENOTEMPTY&#x27; || err.code === &#x27;EEXIST&#x27; || err.code === &#x27;EPERM&#x27;) {
          removeSync(dest)
          options.overwrite = false // just overwriteed it, no need to do it again
          return moveSync(src, dest, options)
        }

        if (err.code !== &#x27;EXDEV&#x27;) throw err
        return moveSyncAcrossDevice(src, dest, overwrite)
      }
    } else {
      try {
        fs.linkSync(src, dest)
        return fs.unlinkSync(src)
      } catch (err) {
        if (err.code === &#x27;EXDEV&#x27; || err.code === &#x27;EISDIR&#x27; || err.code === &#x27;EPERM&#x27; || err.code === &#x27;ENOTSUP&#x27;) {
          return moveSyncAcrossDevice(src, dest, overwrite)
        }
        throw err
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.open" id="apidoc.element.fs-extra-promise.open">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>open
        <span class="apidocSignatureSpan">(path, flags, mode, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function open(path, flags, mode, cb) {
  if (typeof mode === &#x27;function&#x27;)
    cb = mode, mode = null

  return go$open(path, flags, mode, cb)

  function go$open (path, flags, mode, cb) {
    return fs$open(path, flags, mode, function (err, fd) {
      if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
        enqueue([go$open, [path, flags, mode, cb]])
      else {
        if (typeof cb === &#x27;function&#x27;)
          cb.apply(this, arguments)
        retry()
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.openAsync" id="apidoc.element.fs-extra-promise.openAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>openAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.openSync" id="apidoc.element.fs-extra-promise.openSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>openSync
        <span class="apidocSignatureSpan">(path, flags, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openSync = function (path, flags, mode) {
  mode = modeNum(mode, 0o666);
  nullCheck(path);
  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputFile" id="apidoc.element.fs-extra-promise.outputFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputFile
        <span class="apidocSignatureSpan">(file, data, encoding, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputFile(file, data, encoding, callback) {
  if (typeof encoding === &#x27;function&#x27;) {
    callback = encoding
    encoding = &#x27;utf8&#x27;
  }

  const dir = path.dirname(file)
  fs.exists(dir, itDoes =&#x3e; {
    if (itDoes) return fs.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err =&#x3e; {
      if (err) return callback(err)

      fs.writeFile(file, data, encoding, callback)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputFileAsync" id="apidoc.element.fs-extra-promise.outputFileAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputFileAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputFileAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputFileSync" id="apidoc.element.fs-extra-promise.outputFileSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputFileSync
        <span class="apidocSignatureSpan">(file, data, encoding)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputFileSync(file, data, encoding) {
  const dir = path.dirname(file)
  if (fs.existsSync(dir)) {
    return fs.writeFileSync.apply(fs, arguments)
  }
  mkdir.mkdirsSync(dir)
  fs.writeFileSync.apply(fs, arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputJSON" id="apidoc.element.fs-extra-promise.outputJSON">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJSON
        <span class="apidocSignatureSpan">(file, data, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputJson(file, data, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options
    options = {}
  }

  const dir = path.dirname(file)

  fs.exists(dir, itDoes =&#x3e; {
    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

    mkdir.mkdirs(dir, err =&#x3e; {
      if (err) return callback(err)
      jsonFile.writeJson(file, data, options, callback)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputJSONAsync" id="apidoc.element.fs-extra-promise.outputJSONAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJSONAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputJSONAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputJSONSync" id="apidoc.element.fs-extra-promise.outputJSONSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJSONSync
        <span class="apidocSignatureSpan">(file, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputJsonSync(file, data, options) {
  const dir = path.dirname(file)

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  jsonFile.writeJsonSync(file, data, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputJson" id="apidoc.element.fs-extra-promise.outputJson">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJson
        <span class="apidocSignatureSpan">(file, data, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputJson(file, data, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options
    options = {}
  }

  const dir = path.dirname(file)

  fs.exists(dir, itDoes =&#x3e; {
    if (itDoes) return jsonFile.writeJson(file, data, options, callback)

    mkdir.mkdirs(dir, err =&#x3e; {
      if (err) return callback(err)
      jsonFile.writeJson(file, data, options, callback)
    })
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputJsonAsync" id="apidoc.element.fs-extra-promise.outputJsonAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJsonAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">outputJsonAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.outputJsonSync" id="apidoc.element.fs-extra-promise.outputJsonSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>outputJsonSync
        <span class="apidocSignatureSpan">(file, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputJsonSync(file, data, options) {
  const dir = path.dirname(file)

  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  jsonFile.writeJsonSync(file, data, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.read" id="apidoc.element.fs-extra-promise.read">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>read
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (fd, buffer, offset, length, position, callback_) {
  var callback
  if (callback_ &#x26;&#x26; typeof callback_ === &#x27;function&#x27;) {
    var eagCounter = 0
    callback = function (er, _, __) {
      if (er &#x26;&#x26; er.code === &#x27;EAGAIN&#x27; &#x26;&#x26; eagCounter &#x3c; 10) {
        eagCounter ++
        return fs$read.call(fs, fd, buffer, offset, length, position, callback)
      }
      callback_.apply(this, arguments)
    }
  }
  return fs$read.call(fs, fd, buffer, offset, length, position, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readAsync" id="apidoc.element.fs-extra-promise.readAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2, _arg3, _arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readAsync = function (_arg0, _arg1, _arg2, _arg3, _arg4) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 5:ret = callback.call(this, _arg0, _arg1, _arg2, _arg3, _arg4, nodeback); break;
case 4:ret = callback.call(this, _arg0, _arg1, _arg2, _arg3, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readFile" id="apidoc.element.fs-extra-promise.readFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readFile
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFile(path, options, cb) {
  if (typeof options === &#x27;function&#x27;)
    cb = options, options = null

  return go$readFile(path, options, cb)

  function go$readFile (path, options, cb) {
    return fs$readFile(path, options, function (err) {
      if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
        enqueue([go$readFile, [path, options, cb]])
      else {
        if (typeof cb === &#x27;function&#x27;)
          cb.apply(this, arguments)
        retry()
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Additionally, it creates promisified versions of all `fs`&#x27;s and `fs-extra`&#x27;s async methods, using [bluebird](https://www
.npmjs.org/package/bluebird). These methods are named the same as the original `fs`/`fs-extra` methods with `&#x27;Async&#x27;`
added to the end of the method names.

So instead of:

```js
var fs = require(&#x27;fs&#x27;);
fs.<span class="apidocCodeKeywordSpan">readFile</span>(path, function(err, data) {
	console.log(data);
});
```

You can now:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readFileAsync" id="apidoc.element.fs-extra-promise.readFileAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readFileAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

You can now:

```js
var fs = require(&#x27;fs-extra-promise&#x27;);
fs.<span class="apidocCodeKeywordSpan">readFileAsync</span>(path).then(function(data) {
	console.log(data);
});
```

All original `fs` and `fs-extra` methods are included unmodified.

### `isDirectory()` methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readFileSync" id="apidoc.element.fs-extra-promise.readFileSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readFileSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readFileSync = function (path, options) {
  if (!options) {
    options = { encoding: null, flag: &#x27;r&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, flag: &#x27;r&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  var encoding = options.encoding;
  assertEncoding(encoding);

  var flag = options.flag || &#x27;r&#x27;;
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, 0o666);

  var st = tryStatSync(fd, isUserFd);
  var size = st.isFile() ? st.size : 0;
  var pos = 0;
  var buffer; // single buffer with file data
  var buffers; // list for when size is unknown

  if (size === 0) {
    buffers = [];
  } else {
    buffer = tryCreateBuffer(size, fd, isUserFd);
  }

  var bytesRead;

  if (size !== 0) {
    do {
      bytesRead = tryReadSync(fd, isUserFd, buffer, pos, size - pos);
      pos += bytesRead;
    } while (bytesRead !== 0 &#x26;&#x26; pos &#x3c; size);
  } else {
    do {
      // the kernel lies about many files.
      // Go ahead and try to read some bytes.
      buffer = Buffer.allocUnsafe(8192);
      bytesRead = tryReadSync(fd, isUserFd, buffer, 0, 8192);
      if (bytesRead !== 0) {
        buffers.push(buffer.slice(0, bytesRead));
      }
      pos += bytesRead;
    } while (bytesRead !== 0);
  }

  if (!isUserFd)
    fs.closeSync(fd);

  if (size === 0) {
    // data was collected into the buffers list.
    buffer = Buffer.concat(buffers, pos);
  } else if (pos &#x3c; size) {
    buffer = buffer.slice(0, pos);
  }

  if (encoding) buffer = buffer.toString(encoding);
  return buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readJSON" id="apidoc.element.fs-extra-promise.readJSON">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJSON
        <span class="apidocSignatureSpan">(file, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFile(file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  // DO NOT USE &#x27;passParsingErrors&#x27; THE NAME WILL CHANGE!!!, use &#x27;throws&#x27; instead
  if (&#x27;passParsingErrors&#x27; in options) {
    shouldThrow = options.passParsingErrors
  } else if (&#x27;throws&#x27; in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + &#x27;: &#x27; + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readJSONAsync" id="apidoc.element.fs-extra-promise.readJSONAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJSONAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readJSONAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readJSONSync" id="apidoc.element.fs-extra-promise.readJSONSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJSONSync
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFileSync(file, options) {
  options = options || {}
  if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  // DO NOT USE &#x27;passParsingErrors&#x27; THE NAME WILL CHANGE!!!, use &#x27;throws&#x27; instead
  if (&#x27;passParsingErrors&#x27; in options) {
    shouldThrow = options.passParsingErrors
  } else if (&#x27;throws&#x27; in options) {
    shouldThrow = options.throws
  }

  var content = fs.readFileSync(file, options)
  content = stripBom(content)

  try {
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + &#x27;: &#x27; + err.message
      throw err
    } else {
      return null
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readJson" id="apidoc.element.fs-extra-promise.readJson">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJson
        <span class="apidocSignatureSpan">(file, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFile(file, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }

  if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options}
  }

  options = options || {}
  var fs = options.fs || _fs

  var shouldThrow = true
  // DO NOT USE &#x27;passParsingErrors&#x27; THE NAME WILL CHANGE!!!, use &#x27;throws&#x27; instead
  if (&#x27;passParsingErrors&#x27; in options) {
    shouldThrow = options.passParsingErrors
  } else if (&#x27;throws&#x27; in options) {
    shouldThrow = options.throws
  }

  fs.readFile(file, options, function (err, data) {
    if (err) return callback(err)

    data = stripBom(data)

    var obj
    try {
      obj = JSON.parse(data, options ? options.reviver : null)
    } catch (err2) {
      if (shouldThrow) {
        err2.message = file + &#x27;: &#x27; + err2.message
        return callback(err2)
      } else {
        return callback(null, null)
      }
    }

    callback(null, obj)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readJsonAsync" id="apidoc.element.fs-extra-promise.readJsonAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJsonAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readJsonAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readJsonSync" id="apidoc.element.fs-extra-promise.readJsonSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readJsonSync
        <span class="apidocSignatureSpan">(file, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readFileSync(file, options) {
  options = options || {}
  if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options}
  }

  var fs = options.fs || _fs

  var shouldThrow = true
  // DO NOT USE &#x27;passParsingErrors&#x27; THE NAME WILL CHANGE!!!, use &#x27;throws&#x27; instead
  if (&#x27;passParsingErrors&#x27; in options) {
    shouldThrow = options.passParsingErrors
  } else if (&#x27;throws&#x27; in options) {
    shouldThrow = options.throws
  }

  var content = fs.readFileSync(file, options)
  content = stripBom(content)

  try {
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = file + &#x27;: &#x27; + err.message
      throw err
    } else {
      return null
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readSync" id="apidoc.element.fs-extra-promise.readSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readSync
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readSync = function (fd, buffer, offset, length, position) {
  var eagCounter = 0
  while (true) {
    try {
      return fs$readSync.call(fs, fd, buffer, offset, length, position)
    } catch (er) {
      if (er.code === &#x27;EAGAIN&#x27; &#x26;&#x26; eagCounter &#x3c; 10) {
        eagCounter ++
        continue
      }
      throw er
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readdir" id="apidoc.element.fs-extra-promise.readdir">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readdir
        <span class="apidocSignatureSpan">(path, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readdir(path, options, cb) {
  var args = [path]
  if (typeof options !== &#x27;function&#x27;) {
    args.push(options)
  } else {
    cb = options
  }
  args.push(go$readdir$cb)

  return go$readdir(args)

  function go$readdir$cb (err, files) {
    if (files &#x26;&#x26; files.sort)
      files.sort()

    if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
      enqueue([go$readdir, [args]])
    else {
      if (typeof cb === &#x27;function&#x27;)
        cb.apply(this, arguments)
      retry()
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readdirAsync" id="apidoc.element.fs-extra-promise.readdirAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readdirAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readdirSync" id="apidoc.element.fs-extra-promise.readdirSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readdirSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readdirSync = function (path, options) {
  options = options || {};
  if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(path);
  return binding.readdir(pathModule._makeLong(path), options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readlink" id="apidoc.element.fs-extra-promise.readlink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readlink
        <span class="apidocSignatureSpan">(path, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlink = function (path, options, callback) {
  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.readlink(pathModule._makeLong(path), options.encoding, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readlinkAsync" id="apidoc.element.fs-extra-promise.readlinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readlinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.readlinkSync" id="apidoc.element.fs-extra-promise.readlinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>readlinkSync
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readlinkSync = function (path, options) {
  options = options || {};
  if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(path);
  return binding.readlink(pathModule._makeLong(path), options.encoding);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.realpath" id="apidoc.element.fs-extra-promise.realpath">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>realpath
        <span class="apidocSignatureSpan">(p, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realpath(p, options, callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    callback = maybeCallback(options);
    options = {};
  }

  if (!options) {
    options = {};
  } else if (typeof options === &#x27;function&#x27;) {
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  } else if (typeof options !== &#x27;object&#x27;) {
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  }
  if (!nullCheck(p, callback))
    return;

  p = p.toString(&#x27;utf8&#x27;);
  p = pathModule.resolve(p);

  const seenLinks = {};
  const knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = &#x27;&#x27;;

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows &#x26;&#x26; !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return callback(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos &#x3e;= p.length) {
      return callback(null, encodeRealpathResult(p, options));
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base]) {
      return process.nextTick(LOOP);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return callback(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      return process.nextTick(LOOP);
    }

    // stat &#x26; read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    let id;
    if (!isWindows) {
      id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`;
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return callback(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return callback(err);

    var resolvedLink = pathModule.resolve(previous, target);
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.realpathAsync" id="apidoc.element.fs-extra-promise.realpathAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>realpathAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">realpathAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.realpathSync" id="apidoc.element.fs-extra-promise.realpathSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>realpathSync
        <span class="apidocSignatureSpan">(p, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function realpathSync(p, options) {
  if (!options)
    options = {};
  else if (typeof options === &#x27;string&#x27;)
    options = {encoding: options};
  else if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);
  nullCheck(p);

  p = p.toString(&#x27;utf8&#x27;);
  p = pathModule.resolve(p);

  const seenLinks = {};
  const knownHard = {};
  const cache = options[realpathCacheKey];
  const original = p;

  const maybeCachedResult = cache &#x26;&#x26; cache.get(p);
  if (maybeCachedResult) {
    return maybeCachedResult;
  }

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = &#x27;&#x27;;

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows &#x26;&#x26; !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos &#x3c; p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache &#x26;&#x26; cache.get(base) === base)) {
      continue;
    }

    var resolvedLink;
    const maybeCachedResolved = cache &#x26;&#x26; cache.get(base);
    if (maybeCachedResolved) {
      resolvedLink = maybeCachedResolved;
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache.set(base, base);
        continue;
      }

      // read the link if it wasn&#x27;t read before
      // dev/ino always return 0 on windows, so skip the check.
      let linkTarget = null;
      let id;
      if (!isWindows) {
        id = `${stat.dev.toString(32)}:${stat.ino.toString(32)}`;
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);

      if (cache) cache.set(base, resolvedLink);
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache.set(original, p);
  return encodeRealpathResult(p, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.remove" id="apidoc.element.fs-extra-promise.remove">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>remove
        <span class="apidocSignatureSpan">(dir, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(dir, callback) {
  const options = {disableGlob: true}
  return callback ? rimraf(dir, options, callback) : rimraf(dir, options, function () {})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.removeAsync" id="apidoc.element.fs-extra-promise.removeAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>removeAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.removeSync" id="apidoc.element.fs-extra-promise.removeSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>removeSync
        <span class="apidocSignatureSpan">(dir)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeSync(dir) {
  return rimraf.sync(dir, {disableGlob: true})
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.rename" id="apidoc.element.fs-extra-promise.rename">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>rename
        <span class="apidocSignatureSpan">(oldPath, newPath, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (oldPath, newPath, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(oldPath, callback)) return;
  if (!nullCheck(newPath, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rename(pathModule._makeLong(oldPath),
                 pathModule._makeLong(newPath),
                 req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.renameAsync" id="apidoc.element.fs-extra-promise.renameAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>renameAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renameAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.renameSync" id="apidoc.element.fs-extra-promise.renameSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>renameSync
        <span class="apidocSignatureSpan">(oldPath, newPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renameSync = function (oldPath, newPath) {
  nullCheck(oldPath);
  nullCheck(newPath);
  return binding.rename(pathModule._makeLong(oldPath),
                        pathModule._makeLong(newPath));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.rmdir" id="apidoc.element.fs-extra-promise.rmdir">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>rmdir
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdir = function (path, callback) {
  callback = maybeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.rmdir(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.rmdirAsync" id="apidoc.element.fs-extra-promise.rmdirAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>rmdirAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdirAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.rmdirSync" id="apidoc.element.fs-extra-promise.rmdirSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>rmdirSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rmdirSync = function (path) {
  nullCheck(path);
  return binding.rmdir(pathModule._makeLong(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.stat" id="apidoc.element.fs-extra-promise.stat">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>stat
        <span class="apidocSignatureSpan">(target, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stat = function (target, cb) {
  return orig.call(fs, target, function (er, stats) {
    if (!stats) return cb.apply(this, arguments)
    if (stats.uid &#x3c; 0) stats.uid += 0x100000000
    if (stats.gid &#x3c; 0) stats.gid += 0x100000000
    if (cb) cb.apply(this, arguments)
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

All original `fs` and `fs-extra` methods are included unmodified.

### `isDirectory()` methods

For convenience, additional methods `isDirectory()`, `isDirectorySync()` and `isDirectoryAsync()` are provided.

These are are shortcuts for doing `fs.<span class="apidocCodeKeywordSpan">stat</span>()` followed by running `isDirectory()` on
the result returned by `stat()`.

### `usePromise()` method

Creates a new instance of `fs-extra-promise`, which uses the Promise implementation provided.

```js
var Bluebird = require(&#x27;bluebird&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.statAsync" id="apidoc.element.fs-extra-promise.statAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>statAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.statSync" id="apidoc.element.fs-extra-promise.statSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>statSync
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statSync = function (target) {
  var stats = orig.call(fs, target)
  if (stats.uid &#x3c; 0) stats.uid += 0x100000000
  if (stats.gid &#x3c; 0) stats.gid += 0x100000000
  return stats;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.symlink" id="apidoc.element.fs-extra-promise.symlink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>symlink
        <span class="apidocSignatureSpan">(target, path, type_, callback_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlink = function (target, path, type_, callback_) {
  var type = (typeof type_ === &#x27;string&#x27; ? type_ : null);
  var callback = makeCallback(arguments[arguments.length - 1]);

  if (!nullCheck(target, callback)) return;
  if (!nullCheck(path, callback)) return;

  var req = new FSReqWrap();
  req.oncomplete = callback;

  binding.symlink(preprocessSymlinkDestination(target, type, path),
                  pathModule._makeLong(path),
                  type,
                  req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.symlinkAsync" id="apidoc.element.fs-extra-promise.symlinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>symlinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.symlinkSync" id="apidoc.element.fs-extra-promise.symlinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>symlinkSync
        <span class="apidocSignatureSpan">(target, path, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">symlinkSync = function (target, path, type) {
  type = (typeof type === &#x27;string&#x27; ? type : null);

  nullCheck(target);
  nullCheck(path);

  return binding.symlink(preprocessSymlinkDestination(target, type, path),
                         pathModule._makeLong(path),
                         type);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.truncate" id="apidoc.element.fs-extra-promise.truncate">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>truncate
        <span class="apidocSignatureSpan">(path, len, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncate = function (path, len, callback) {
  if (typeof path === &#x27;number&#x27;) {
    return fs.ftruncate(path, len, callback);
  }
  if (typeof len === &#x27;function&#x27;) {
    callback = len;
    len = 0;
  } else if (len === undefined) {
    len = 0;
  }

  callback = maybeCallback(callback);
  fs.open(path, &#x27;r+&#x27;, function(er, fd) {
    if (er) return callback(er);
    var req = new FSReqWrap();
    req.oncomplete = function oncomplete(er) {
      fs.close(fd, function(er2) {
        callback(er || er2);
      });
    };
    binding.ftruncate(fd, len, req);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.truncateAsync" id="apidoc.element.fs-extra-promise.truncateAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>truncateAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncateAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.truncateSync" id="apidoc.element.fs-extra-promise.truncateSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>truncateSync
        <span class="apidocSignatureSpan">(path, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">truncateSync = function (path, len) {
  if (typeof path === &#x27;number&#x27;) {
    // legacy
    return fs.ftruncateSync(path, len);
  }
  if (len === undefined) {
    len = 0;
  }
  // allow error to be thrown, but still close fd.
  var fd = fs.openSync(path, &#x27;r+&#x27;);
  var ret;

  try {
    ret = fs.ftruncateSync(fd, len);
  } finally {
    fs.closeSync(fd);
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.unlink" id="apidoc.element.fs-extra-promise.unlink">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>unlink
        <span class="apidocSignatureSpan">(path, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlink = function (path, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.unlink(pathModule._makeLong(path), req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.unlinkAsync" id="apidoc.element.fs-extra-promise.unlinkAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>unlinkAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlinkAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.unlinkSync" id="apidoc.element.fs-extra-promise.unlinkSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>unlinkSync
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unlinkSync = function (path) {
  nullCheck(path);
  return binding.unlink(pathModule._makeLong(path));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.unwatchFile" id="apidoc.element.fs-extra-promise.unwatchFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>unwatchFile
        <span class="apidocSignatureSpan">(filename, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwatchFile = function (filename, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat = statWatchers.get(filename);

  if (stat === undefined) return;

  if (typeof listener === &#x27;function&#x27;) {
    stat.removeListener(&#x27;change&#x27;, listener);
  } else {
    stat.removeAllListeners(&#x27;change&#x27;);
  }

  if (stat.listenerCount(&#x27;change&#x27;) === 0) {
    stat.stop();
    statWatchers.delete(filename);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.useFs" id="apidoc.element.fs-extra-promise.useFs">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>useFs
        <span class="apidocSignatureSpan">(fs, Promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fs =&#x3e; factory(fs, Promise)</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### `useFs()` method

Creates a new instance of `fs-extra-promise`, promisifying the provide version of [fs-extra](https://www.npmjs.org/package/fs-extra
).

Most useful if you want to use a specific version of [fs-extra](https://www.npmjs.org/package/fs-extra).

```js
var fs = require(&#x27;fs-extra-promise&#x27;).<span class="apidocCodeKeywordSpan">useFs</span>(require(&#x27;fs-extra&#x27;));
```

## Tests

Use `npm test` to run the tests. Use `npm run cover` to check coverage.

There aren&#x27;t any tests at present, except for running jshint on the code.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.usePromise" id="apidoc.element.fs-extra-promise.usePromise">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>usePromise
        <span class="apidocSignatureSpan">(fsOriginal, Promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Promise =&#x3e; factory(fsOriginal, Promise)</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### `usePromise()` method

Creates a new instance of `fs-extra-promise`, which uses the Promise implementation provided.

```js
var Bluebird = require(&#x27;bluebird&#x27;);
var fs = require(&#x27;fs-extra-promise&#x27;).<span class="apidocCodeKeywordSpan">usePromise</span>(Bluebird);

// now use `fs-extra-promise` in the usual way
var promise = fs.readFileAsync(path);

console.log(promise instanceof Bluebird); // true
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.utimes" id="apidoc.element.fs-extra-promise.utimes">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>utimes
        <span class="apidocSignatureSpan">(path, atime, mtime, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimes = function (path, atime, mtime, callback) {
  callback = makeCallback(callback);
  if (!nullCheck(path, callback)) return;
  var req = new FSReqWrap();
  req.oncomplete = callback;
  binding.utimes(pathModule._makeLong(path),
                 toUnixTimestamp(atime),
                 toUnixTimestamp(mtime),
                 req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.utimesAsync" id="apidoc.element.fs-extra-promise.utimesAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>utimesAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimesAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.utimesSync" id="apidoc.element.fs-extra-promise.utimesSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>utimesSync
        <span class="apidocSignatureSpan">(path, atime, mtime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">utimesSync = function (path, atime, mtime) {
  nullCheck(path);
  atime = toUnixTimestamp(atime);
  mtime = toUnixTimestamp(mtime);
  binding.utimes(pathModule._makeLong(path), atime, mtime);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.watch" id="apidoc.element.fs-extra-promise.watch">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>watch
        <span class="apidocSignatureSpan">(filename, options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watch = function (filename, options, listener) {
  nullCheck(filename);

  options = options || {};
  if (typeof options === &#x27;function&#x27;) {
    listener = options;
    options = {};
  } else if (typeof options === &#x27;string&#x27;) {
    options = {encoding: options};
  }
  if (typeof options !== &#x27;object&#x27;)
    throw new TypeError(&#x27;&#x22;options&#x22; must be a string or an object&#x27;);

  if (options.persistent === undefined) options.persistent = true;
  if (options.recursive === undefined) options.recursive = false;

  const watcher = new FSWatcher();
  watcher.start(filename,
                options.persistent,
                options.recursive,
                options.encoding);

  if (listener) {
    watcher.addListener(&#x27;change&#x27;, listener);
  }

  return watcher;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.watchFile" id="apidoc.element.fs-extra-promise.watchFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>watchFile
        <span class="apidocSignatureSpan">(filename, options, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">watchFile = function (filename, options, listener) {
  nullCheck(filename);
  filename = pathModule.resolve(filename);
  var stat;

  var defaults = {
    // Poll interval in milliseconds. 5007 is what libev used to use. It&#x27;s
    // a little on the slow side but let&#x27;s stick with it for now to keep
    // behavioral changes to a minimum.
    interval: 5007,
    persistent: true
  };

  if (options !== null &#x26;&#x26; typeof options === &#x27;object&#x27;) {
    options = util._extend(defaults, options);
  } else {
    listener = options;
    options = defaults;
  }

  if (typeof listener !== &#x27;function&#x27;) {
    throw new Error(&#x27;&#x22;watchFile()&#x22; requires a listener function&#x27;);
  }

  stat = statWatchers.get(filename);

  if (stat === undefined) {
    stat = new StatWatcher();
    stat.start(filename, options.persistent, options.interval);
    statWatchers.set(filename, stat);
  }

  stat.addListener(&#x27;change&#x27;, listener);
  return stat;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.write" id="apidoc.element.fs-extra-promise.write">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>write
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function (fd, buffer, offset, length, position, callback) {
  function wrapper(err, written) {
    // Retain a reference to buffer so that it can&#x27;t be GC&#x27;ed too soon.
    callback(err, written || 0, buffer);
  }

  var req = new FSReqWrap();
  req.oncomplete = wrapper;

  if (buffer instanceof Buffer) {
    // if no position is passed then assume null
    if (typeof position === &#x27;function&#x27;) {
      callback = position;
      position = null;
    }
    callback = maybeCallback(callback);
    return binding.writeBuffer(fd, buffer, offset, length, position, req);
  }

  if (typeof buffer !== &#x27;string&#x27;)
    buffer += &#x27;&#x27;;
  if (typeof position !== &#x27;function&#x27;) {
    if (typeof offset === &#x27;function&#x27;) {
      position = offset;
      offset = null;
    } else {
      position = length;
    }
    length = &#x27;utf8&#x27;;
  }
  callback = maybeCallback(position);
  return binding.writeString(fd, buffer, offset, length, req);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeAsync" id="apidoc.element.fs-extra-promise.writeAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2, _arg3, _arg4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeAsync = function (_arg0, _arg1, _arg2, _arg3, _arg4) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 5:ret = callback.call(this, _arg0, _arg1, _arg2, _arg3, _arg4, nodeback); break;
case 4:ret = callback.call(this, _arg0, _arg1, _arg2, _arg3, nodeback); break;
case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeFile" id="apidoc.element.fs-extra-promise.writeFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeFile
        <span class="apidocSignatureSpan">(path, data, options, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFile(path, data, options, cb) {
  if (typeof options === &#x27;function&#x27;)
    cb = options, options = null

  return go$writeFile(path, data, options, cb)

  function go$writeFile (path, data, options, cb) {
    return fs$writeFile(path, data, options, function (err) {
      if (err &#x26;&#x26; (err.code === &#x27;EMFILE&#x27; || err.code === &#x27;ENFILE&#x27;))
        enqueue([go$writeFile, [path, data, options, cb]])
      else {
        if (typeof cb === &#x27;function&#x27;)
          cb.apply(this, arguments)
        retry()
      }
    })
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeFileAsync" id="apidoc.element.fs-extra-promise.writeFileAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeFileAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFileAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeFileSync" id="apidoc.element.fs-extra-promise.writeFileSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeFileSync
        <span class="apidocSignatureSpan">(path, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFileSync = function (path, data, options) {
  if (!options) {
    options = { encoding: &#x27;utf8&#x27;, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options === &#x27;string&#x27;) {
    options = { encoding: options, mode: 0o666, flag: &#x27;w&#x27; };
  } else if (typeof options !== &#x27;object&#x27;) {
    throwOptionsError(options);
  }

  assertEncoding(options.encoding);

  var flag = options.flag || &#x27;w&#x27;;
  var isUserFd = isFd(path); // file descriptor ownership
  var fd = isUserFd ? path : fs.openSync(path, flag, options.mode);

  if (!(data instanceof Buffer)) {
    data = Buffer.from(&#x27;&#x27; + data, options.encoding || &#x27;utf8&#x27;);
  }
  var offset = 0;
  var length = data.length;
  var position = /a/.test(flag) ? null : 0;
  try {
    while (length &#x3e; 0) {
      var written = fs.writeSync(fd, data, offset, length, position);
      offset += written;
      length -= written;
      if (position !== null) {
        position += written;
      }
    }
  } finally {
    if (!isUserFd) fs.closeSync(fd);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeJSON" id="apidoc.element.fs-extra-promise.writeJSON">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJSON
        <span class="apidocSignatureSpan">(file, obj, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFile(file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var spaces = typeof options === &#x27;object&#x27; &#x26;&#x26; options !== null
    ? &#x27;spaces&#x27; in options
    ? options.spaces : this.spaces
    : this.spaces

  var str = &#x27;&#x27;
  try {
    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + &#x27;\n&#x27;
  } catch (err) {
    if (callback) return callback(err, null)
  }

  fs.writeFile(file, str, options, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeJSONAsync" id="apidoc.element.fs-extra-promise.writeJSONAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJSONAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeJSONAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeJSONSync" id="apidoc.element.fs-extra-promise.writeJSONSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJSONSync
        <span class="apidocSignatureSpan">(file, obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFileSync(file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var spaces = typeof options === &#x27;object&#x27; &#x26;&#x26; options !== null
    ? &#x27;spaces&#x27; in options
    ? options.spaces : this.spaces
    : this.spaces

  var str = JSON.stringify(obj, options.replacer, spaces) + &#x27;\n&#x27;
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeJson" id="apidoc.element.fs-extra-promise.writeJson">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJson
        <span class="apidocSignatureSpan">(file, obj, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFile(file, obj, options, callback) {
  if (callback == null) {
    callback = options
    options = {}
  }
  options = options || {}
  var fs = options.fs || _fs

  var spaces = typeof options === &#x27;object&#x27; &#x26;&#x26; options !== null
    ? &#x27;spaces&#x27; in options
    ? options.spaces : this.spaces
    : this.spaces

  var str = &#x27;&#x27;
  try {
    str = JSON.stringify(obj, options ? options.replacer : null, spaces) + &#x27;\n&#x27;
  } catch (err) {
    if (callback) return callback(err, null)
  }

  fs.writeFile(file, str, options, callback)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeJsonAsync" id="apidoc.element.fs-extra-promise.writeJsonAsync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJsonAsync
        <span class="apidocSignatureSpan">(_arg0, _arg1, _arg2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeJsonAsync = function (_arg0, _arg1, _arg2) {
    &#x27;use strict&#x27;;
    var len = arguments.length;
    var promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    var nodeback = nodebackForPromise(promise, false);
    var ret;
    var callback = tryCatch(fn);
    switch(len) {
        case 3:ret = callback.call(this, _arg0, _arg1, _arg2, nodeback); break;
case 2:ret = callback.call(this, _arg0, _arg1, nodeback); break;
case 1:ret = callback.call(this, _arg0, nodeback); break;
case 0:ret = callback.call(this, nodeback); break;

default:
    var args = new Array(len + 1);
    var i = 0;
    for (var i = 0; i &#x3c; len; ++i) {
       args[i] = arguments[i];
    }
    args[i] = nodeback;
    ret = callback.apply(this, args);

    break;

    }
    if (ret === errorObj) {
        promise._rejectCallback(maybeWrapAsError(ret.e), true, true);
    }
    if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeJsonSync" id="apidoc.element.fs-extra-promise.writeJsonSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeJsonSync
        <span class="apidocSignatureSpan">(file, obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeFileSync(file, obj, options) {
  options = options || {}
  var fs = options.fs || _fs

  var spaces = typeof options === &#x27;object&#x27; &#x26;&#x26; options !== null
    ? &#x27;spaces&#x27; in options
    ? options.spaces : this.spaces
    : this.spaces

  var str = JSON.stringify(obj, options.replacer, spaces) + &#x27;\n&#x27;
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.writeSync" id="apidoc.element.fs-extra-promise.writeSync">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>writeSync
        <span class="apidocSignatureSpan">(fd, buffer, offset, length, position)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeSync = function (fd, buffer, offset, length, position) {
  if (buffer instanceof Buffer) {
    if (position === undefined)
      position = null;
    return binding.writeBuffer(fd, buffer, offset, length, position);
  }
  if (typeof buffer !== &#x27;string&#x27;)
    buffer += &#x27;&#x27;;
  if (offset === undefined)
    offset = null;
  return binding.writeString(fd, buffer, offset, length, position);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise.ReadStream" id="apidoc.module.fs-extra-promise.ReadStream">module fs-extra-promise.ReadStream</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.ReadStream.ReadStream" id="apidoc.element.fs-extra-promise.ReadStream.ReadStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>ReadStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream(path, options) {
  if (this instanceof ReadStream)
    return fs$ReadStream.apply(this, arguments), this
  else
    return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise.ReadStream.prototype" id="apidoc.module.fs-extra-promise.ReadStream.prototype">module fs-extra-promise.ReadStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.ReadStream.prototype.open" id="apidoc.element.fs-extra-promise.ReadStream.prototype.open">
        function <span class="apidocSignatureSpan">fs-extra-promise.ReadStream.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ReadStream$open() {
  var that = this
  open(that.path, that.flags, that.mode, function (err, fd) {
    if (err) {
      if (that.autoClose)
        that.destroy()

      that.emit(&#x27;error&#x27;, err)
    } else {
      that.fd = fd
      that.emit(&#x27;open&#x27;, fd)
      that.read()
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise.Stats" id="apidoc.module.fs-extra-promise.Stats">module fs-extra-promise.Stats</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.Stats" id="apidoc.element.fs-extra-promise.Stats.Stats">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>Stats
        <span class="apidocSignatureSpan">( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Stats( dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atim_msec, mtim_msec, ctim_msec, birthtim_msec) {
  this.dev = dev;
  this.mode = mode;
  this.nlink = nlink;
  this.uid = uid;
  this.gid = gid;
  this.rdev = rdev;
  this.blksize = blksize;
  this.ino = ino;
  this.size = size;
  this.blocks = blocks;
  this.atime = new Date(atim_msec);
  this.mtime = new Date(mtim_msec);
  this.ctime = new Date(ctim_msec);
  this.birthtime = new Date(birthtim_msec);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise.Stats.prototype" id="apidoc.module.fs-extra-promise.Stats.prototype">module fs-extra-promise.Stats.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype._checkModeProperty" id="apidoc.element.fs-extra-promise.Stats.prototype._checkModeProperty">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>_checkModeProperty
        <span class="apidocSignatureSpan">(property)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_checkModeProperty = function (property) {
  return ((this.mode &#x26; constants.S_IFMT) === property);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isBlockDevice" id="apidoc.element.fs-extra-promise.Stats.prototype.isBlockDevice">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isBlockDevice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBlockDevice = function () {
  return this._checkModeProperty(constants.S_IFBLK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isCharacterDevice" id="apidoc.element.fs-extra-promise.Stats.prototype.isCharacterDevice">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isCharacterDevice
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isCharacterDevice = function () {
  return this._checkModeProperty(constants.S_IFCHR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isDirectory" id="apidoc.element.fs-extra-promise.Stats.prototype.isDirectory">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectory = function () {
  return this._checkModeProperty(constants.S_IFDIR);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isFIFO" id="apidoc.element.fs-extra-promise.Stats.prototype.isFIFO">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isFIFO
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFIFO = function () {
  return this._checkModeProperty(constants.S_IFIFO);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isFile" id="apidoc.element.fs-extra-promise.Stats.prototype.isFile">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isFile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFile = function () {
  return this._checkModeProperty(constants.S_IFREG);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isSocket" id="apidoc.element.fs-extra-promise.Stats.prototype.isSocket">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isSocket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSocket = function () {
  return this._checkModeProperty(constants.S_IFSOCK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.fs-extra-promise.Stats.prototype.isSymbolicLink" id="apidoc.element.fs-extra-promise.Stats.prototype.isSymbolicLink">
        function <span class="apidocSignatureSpan">fs-extra-promise.Stats.prototype.</span>isSymbolicLink
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSymbolicLink = function () {
  return this._checkModeProperty(constants.S_IFLNK);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise.WriteStream" id="apidoc.module.fs-extra-promise.WriteStream">module fs-extra-promise.WriteStream</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.WriteStream.WriteStream" id="apidoc.element.fs-extra-promise.WriteStream.WriteStream">
        function <span class="apidocSignatureSpan">fs-extra-promise.</span>WriteStream
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream(path, options) {
  if (this instanceof WriteStream)
    return fs$WriteStream.apply(this, arguments), this
  else
    return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.fs-extra-promise.WriteStream.prototype" id="apidoc.module.fs-extra-promise.WriteStream.prototype">module fs-extra-promise.WriteStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.fs-extra-promise.WriteStream.prototype.open" id="apidoc.element.fs-extra-promise.WriteStream.prototype.open">
        function <span class="apidocSignatureSpan">fs-extra-promise.WriteStream.prototype.</span>open
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WriteStream$open() {
  var that = this
  open(that.path, that.flags, that.mode, function (err, fd) {
    if (err) {
      that.destroy()
      that.emit(&#x27;error&#x27;, err)
    } else {
      that.fd = fd
      that.emit(&#x27;open&#x27;, fd)
    }
  })
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
